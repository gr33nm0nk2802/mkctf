# =============================================================================
#  IMPORTS
# =============================================================================
import tarfile
from os import urandom
from stat import S_IRWXU
from pathlib import Path
from hashlib import sha1
from asyncio import create_subprocess_exec, wait_for, TimeoutError
from subprocess import PIPE, CalledProcessError
from mkctf.helper.log import app_log
from mkctf.helper.hashing import hash_file
from mkctf.object.configurable import Configurable
# =============================================================================
#  CLASSES
# =============================================================================
class Challenge(Configurable):
    '''[summary]
    '''
    @staticmethod
    def make_flag(repo_conf, size=32):
        '''Makes a flag
        '''
        prefix = repo_conf['flag']['prefix']
        content = urandom(size).hex()
        suffix = repo_conf['flag']['suffix']
        return f"{prefix}{content}{suffix}"

    @staticmethod
    def make_static_url(repo_conf, slug):
        '''Makes challenge static url
        '''
        url = repo_conf['static']['base_url']
        if not url.endswith('/'):
            url += '/'
        key = slug.encode() + bytes.fromhex(repo_conf['static']['salt'])
        url += f'{sha1(key).hexdigest()}.tar.gz'
        return url

    def __init__(self, chall_conf_path, repo_conf):
        '''Constructs a new instance
        '''
        super().__init__(chall_conf_path)
        self.repo_conf = repo_conf

    def __create_dir(self, directory):
        '''Creates a directory
        '''
        dir_path = self.working_dir().joinpath(directory)
        if not dir_path.is_dir():
            dir_path.mkdir(parents=True, exist_ok=True)
            return True
        return False

    def __create_file(self, filename, executable=False):
        '''Creates a file
        '''
        filepath = self.working_dir().joinpath(filename)
        filepath.parent.mkdir(parents=True, exist_ok=True)
        content = []
        if executable:
            content.append('#!/usr/bin/env bash')
        content.append('# file automatically generated by mkctf.')
        if executable:
            content.extend([
                '',
                'function print {',
                '    (>&2 printf "\\x1b[34m${1}\\x1b[0m\\n")',
                '}',
                'function exit_success {',
                '    (>&2 printf "\\x1b[32m- Script succeeded.\\x1b[0m\\n")',
                '    exit 0',
                '}',
                'function exit_failure {',
                '    (>&2 printf "\\x1b[31m- Script failed.\\x1b[0m\\n")',
                '    exit 1',
                '}',
                'function exit_non_applicable {',
                '    (>&2 printf "\\x1b[36m- Script non applicable.\\x1b[0m\\n")',
                '    exit 2',
                '}',
                'function exit_manual {',
                '    (>&2 printf "\\x1b[33m- Script requires a manual operation.\\x1b[0m\\n")',
                '    exit 3',
                '}',
                'function exit_not_implemented {',
                '    (>&2 printf "\\x1b[35m- Script not implemented.\\x1b[0m\\n")',
                '    exit 4',
                '}',
                '',
                'exit_not_implemented',
                ''
            ])

        if not filepath.is_file():
            with filepath.open('w') as fp:
                fp.write('\n'.join(content))
            if executable:
                filepath.chmod(S_IRWXU)
            return True
        return False

    async def __run(self, script, timeout):
        '''Runs a script as an asynchronous subprocess
        '''
        script_path = Path(script)
        script_parents = script_path.parents
        script = f'./{script_path.name}'
        if script_path.is_absolute():
            cwd = script_parents[0]
        else:
            cwd = self.working_dir()
            if len(script_parents) > 1:
                cwd /= script_parents[0]

        app_log.info(f"running {script_path.name} within {cwd}.")
        proc = await create_subprocess_exec(script, stdout=PIPE, stderr=PIPE, cwd=str(cwd))

        rcode = -1
        stdout = None
        stderr = None
        exception = None

        try:
            stdout, stderr = await wait_for(proc.communicate(), timeout=timeout)
            rcode = proc.returncode
        except TimeoutError:
            proc.terminate()
            exception = 'timeout'
        except CalledProcessError as exc:
            proc.terminate()
            rcode = exc.returncode
            stdout = exc.stdout
            stderr = exc.stderr
            exception = 'called process error'
        except Exception as exc:
            exception = str(exc)

        if rcode == 0:
            app_log.info("subprocess terminated successfully.")
        else:
            app_log.warning(f"subprocess terminated unsuccessfully (rcode={rcode}).")

        return {
            'rcode': rcode,
            'stdout': stdout,
            'stderr': stderr,
            'exception': exception
        }

    @property
    def slug(self):
        '''Gets challenge's slug
        '''
        return self.working_dir().name

    @property
    def tags(self):
        '''Gets challenge's category
        '''
        return self.get_conf('tags')

    @property
    def is_standalone(self):
        '''Determines if challenge is static
        '''
        return self.get_conf('standalone')

    @property
    def description(self):
        '''Retrieve challenge description from filesystem
        '''
        desc_path = self.working_dir().joinpath(self.repo_conf['files']['description'])
        if desc_path.is_file():
            return desc_path.read_text()
        return None

    @property
    def enabled(self):
        '''Determine if challenge is enabled
        '''
        return self.get_conf('enabled')

    def enable(self, enabled=True):
        '''Enable or disables the challenge
        '''
        conf = self.get_conf()
        conf['enabled'] = enabled
        self.set_conf(conf)

    def renew_flag(self, size=32):
        '''Renew challenge's flag
        '''
        conf = self.get_conf()
        conf['flag'] = Challenge.make_flag(self.repo_conf, size)
        self.set_conf(conf)
        return conf['flag']

    def update_static_url(self):
        '''Update static_url parameter
        '''
        conf = self.get_conf()
        conf['static_url'] = Challenge.make_static_url(self.repo_conf, self.slug)
        self.set_conf(conf)
        return conf['static_url']

    def create(self):
        '''Create challenge files
        '''
        self.working_dir().mkdir(parents=True, exist_ok=True)

        directories = self.repo_conf['directories']['public'][::]
        directories += self.repo_conf['directories']['private']

        for directory in directories:
            if not self.__create_dir(directory):
                app_log.warning(f"directory exists already: {directory}")

        txt_files = [self.repo_conf['files']['description']]
        txt_files += self.repo_conf['files']['txt']

        for file in txt_files:
            if not self.__create_file(file):
                app_log.warning(f"file exists already: {file}")

        bin_files = [
            self.repo_conf['files']['build'],
            self.repo_conf['files']['deploy'],
            self.repo_conf['files']['status']
        ]

        for file in bin_files:
            if not self.__create_file(file, executable=True):
                app_log.warning(f"file exists already: {file}")

        return True

    def exportable(self):
        '''Yields files contained in public folders
        '''
        wd = self.working_dir()
        for directory in self.repo_conf['directories']['public']:
            dir_path = wd.joinpath(directory)
            for de in self._scandirs(dir_path):
                yield de

    def export(self, export_dir, include_disabled):
        '''Exports challenge

        Creates an archive containing all of the challenge "exportable" files.
        '''
        if not include_disabled and not self.enabled:
            app_log.warning(f"challenge ignored (disabled): {self.slug}.")
            return {'ignored': True}
        app_log.info(f"exporting {self.slug}...")
        conf = self.get_conf()
        archive_name = conf['static_url'].split('/')[-1]
        if not archive_name:
            app_log.error(f"challenge ignored (invalid/empty static_url): {self.slug}")
            app_log.error(f"running `mkctf-cli update-meta` might fix this issue.")
            return {'ignored': True}
        archive_path = export_dir.joinpath(archive_name)
        with tarfile.open(str(archive_path), 'w:gz') as arch:
            for entry in self.exportable():
                arch.add(entry.path, arcname=entry.name)
        checksum_name = f'{archive_name}.sha256'
        checksum_path = export_dir.joinpath(checksum_name)
        archive_hash = hash_file(archive_path)
        checksum_path.write_text(f'{archive_hash}  {archive_name}\n')
        app_log.info("done.")
        return {
            'archive_path': archive_path,
            'checksum_path': checksum_path
        }

    async def build(self, timeout=4):
        '''Builds the challenge
        '''
        return await self.__run(self.repo_conf['files']['build'], timeout)

    async def deploy(self, timeout=4):
        '''Deploys the challenge
        '''
        return await self.__run(self.repo_conf['files']['deploy'], timeout)

    async def status(self, timeout=4):
        '''Queries the status of a deployed challenge
        '''
        return await self.__run(self.repo_conf['files']['status'], timeout)

